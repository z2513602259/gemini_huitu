# 经验教训

## 技术实现经验

### 1. IndexedDB 使用
**经验**：IndexedDB 适合存储大量图片数据
- 使用 `objectStore` 存储历史记录
- 每条记录包含完整的 Base64 图片数据
- 实现自动清理机制（保留最新 100 条）

**教训**：
- IndexedDB API 是异步的，需要正确处理 Promise
- 数据库版本升级需要在 `onupgradeneeded` 中处理
- 大量数据查询时注意性能优化

### 2. 图片拖拽排序
**经验**：使用原生 HTML5 拖拽 API 实现
- `draggable` 属性启用拖拽
- `onDragStart/Over/End` 事件处理
- 实时更新数组顺序提供流畅体验

**实现要点**：
```typescript
// 拖拽开始时记录索引
setDraggedIndex(index)

// 拖拽经过时重新排序
const newImages = [...inputImages]
const draggedItem = newImages[draggedIndex]
newImages.splice(draggedIndex, 1)
newImages.splice(index, 0, draggedItem)
setInputImages(newImages)
setDraggedIndex(index)

// 拖拽结束时清理状态
setDraggedIndex(null)
```

### 3. 全局粘贴监听
**经验**：支持全局粘贴图片提升用户体验
- 使用 `window.addEventListener('paste')` 监听全局粘贴事件
- 从 `ClipboardEvent` 中提取图片数据
- 在组件卸载时清理事件监听器

**注意事项**：
- 需要在 `useEffect` 中添加和移除监听器
- 避免内存泄漏

### 4. API Key 安全显示
**经验**：格式化显示 API Key 保护隐私
- 显示首尾各 6 个字符
- 中间用点号（•）替代
- 提供显示/隐藏切换按钮

**实现**：
```typescript
const displayApiKey = useMemo(() => {
  if (showApiKey || !apiKey || apiKey.length <= 12) return apiKey
  return `${apiKey.slice(0, 6)}${'•'.repeat(Math.min(apiKey.length - 12, 20))}${apiKey.slice(-6)}`
}, [apiKey, showApiKey])
```

### 5. 配置管理
**经验**：双层配置系统提供灵活性
- `config.js`：部署后可修改的默认配置
- `localStorage`：用户自定义配置（优先级更高）

**好处**：
- 部署后无需重新构建即可修改默认配置
- 用户配置持久化保存
- 配置合并逻辑清晰

### 6. 模式切换设计
**经验**：使用 `mode` 状态区分生图和工作流模式
- 共享大部分 UI 组件和逻辑
- 根据模式动态调整 UI 和验证规则
- 工作流模式使用预设提示词

**设计优势**：
- 代码复用率高
- 用户体验一致
- 易于扩展新模式

## 架构决策

### 1. 单组件架构
**决策**：主要逻辑集中在 `App.tsx`
**原因**：
- 应用规模较小
- 状态共享频繁
- 避免过度工程化

**适用场景**：小型应用、原型开发
**不适用场景**：大型应用、团队协作

### 2. 无后端架构
**决策**：纯前端应用，直接调用 Gemini API
**优势**：
- 部署简单（静态站点）
- 无服务器成本
- 快速迭代

**劣势**：
- API Key 暴露在前端
- 无法实现复杂的业务逻辑
- 无法进行服务端验证

**改进方向**：
- 使用 EdgeOne 边缘函数作为 API 代理
- 在边缘函数中保管 API Key
- 实现请求频率限制

### 3. Base64 图片处理
**决策**：使用 Base64 编码处理图片
**原因**：
- Gemini API 要求 Base64 格式
- 简化前端处理流程
- 便于存储到 IndexedDB

**权衡**：
- Base64 增加约 33% 数据量
- 大图片编码/解码可能较慢
- 但避免了文件上传的复杂性

## UI/UX 经验

### 1. 加载状态反馈
**经验**：提供清晰的加载状态
- 显示加载动画
- 禁用生成按钮
- 显示生成用时

**用户体验提升**：
- 用户知道系统正在处理
- 避免重复点击
- 提供性能参考

### 2. 错误处理
**经验**：友好的错误提示
- 捕获 API 错误并显示
- 文件上传错误提示
- 配置验证提示

**改进空间**：
- 更详细的错误分类
- 错误恢复建议
- 错误日志记录

### 3. 响应式设计
**经验**：使用 Flexbox 和 Grid 布局
- 左右面板布局
- 工作流卡片网格
- 图片预览网格

**注意事项**：
- 移动端适配需要进一步优化
- 考虑不同屏幕尺寸

## 性能优化

### 1. useMemo 优化
**经验**：使用 `useMemo` 缓存计算结果
- 宽高比元数据查找
- 分辨率文本生成
- API Key 格式化显示

**效果**：避免不必要的重复计算

### 2. 历史记录限制
**经验**：自动清理旧记录
- 限制最多 100 条
- 按时间戳排序删除最旧的
- 避免 IndexedDB 无限增长

### 3. 图片预览优化
**经验**：使用 `createObjectURL` 生成预览
- 避免重复编码 Base64
- 内存占用更小
- 预览加载更快

## 待解决问题

### 1. 大图片性能
**问题**：4K 图片的 Base64 编码和存储可能较慢
**可能方案**：
- 使用 Web Worker 处理编码
- 压缩图片后再存储
- 实现渐进式加载

### 2. 移动端体验
**问题**：当前主要针对桌面端设计
**改进方向**：
- 响应式布局优化
- 触摸手势支持
- 移动端图片上传优化

### 3. 批量生成
**问题**：当前只支持单次生成
**需求**：支持批量生成多张图片
**挑战**：
- UI 设计
- 进度显示
- 结果管理

## 最佳实践总结

1. **状态管理**：合理使用 useState 和 useMemo，避免过度优化
2. **错误处理**：始终捕获异步操作的错误并提供用户反馈
3. **用户体验**：提供清晰的加载状态和操作反馈
4. **数据持久化**：选择合适的存储方案（IndexedDB vs localStorage）
5. **配置管理**：支持运行时配置提高部署灵活性
6. **代码组织**：小型应用可以接受单组件架构，但要保持代码清晰
7. **安全意识**：前端暴露 API Key 的风险需要明确告知用户
